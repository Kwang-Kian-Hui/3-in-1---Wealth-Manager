// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'firebase_failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$FirebaseFailuresTearOff {
  const _$FirebaseFailuresTearOff();

  CancelledOperation cancelledOperation() {
    return const CancelledOperation();
  }

  ObjectNotFound objectNotFound() {
    return const ObjectNotFound();
  }

  Unknown unknown() {
    return const Unknown();
  }

  NoConnection noConnection() {
    return const NoConnection();
  }
}

/// @nodoc
const $FirebaseFailures = _$FirebaseFailuresTearOff();

/// @nodoc
mixin _$FirebaseFailures {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledOperation,
    required TResult Function() objectNotFound,
    required TResult Function() unknown,
    required TResult Function() noConnection,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? cancelledOperation,
    TResult Function()? objectNotFound,
    TResult Function()? unknown,
    TResult Function()? noConnection,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledOperation,
    TResult Function()? objectNotFound,
    TResult Function()? unknown,
    TResult Function()? noConnection,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CancelledOperation value) cancelledOperation,
    required TResult Function(ObjectNotFound value) objectNotFound,
    required TResult Function(Unknown value) unknown,
    required TResult Function(NoConnection value) noConnection,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(CancelledOperation value)? cancelledOperation,
    TResult Function(ObjectNotFound value)? objectNotFound,
    TResult Function(Unknown value)? unknown,
    TResult Function(NoConnection value)? noConnection,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CancelledOperation value)? cancelledOperation,
    TResult Function(ObjectNotFound value)? objectNotFound,
    TResult Function(Unknown value)? unknown,
    TResult Function(NoConnection value)? noConnection,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FirebaseFailuresCopyWith<$Res> {
  factory $FirebaseFailuresCopyWith(
          FirebaseFailures value, $Res Function(FirebaseFailures) then) =
      _$FirebaseFailuresCopyWithImpl<$Res>;
}

/// @nodoc
class _$FirebaseFailuresCopyWithImpl<$Res>
    implements $FirebaseFailuresCopyWith<$Res> {
  _$FirebaseFailuresCopyWithImpl(this._value, this._then);

  final FirebaseFailures _value;
  // ignore: unused_field
  final $Res Function(FirebaseFailures) _then;
}

/// @nodoc
abstract class $CancelledOperationCopyWith<$Res> {
  factory $CancelledOperationCopyWith(
          CancelledOperation value, $Res Function(CancelledOperation) then) =
      _$CancelledOperationCopyWithImpl<$Res>;
}

/// @nodoc
class _$CancelledOperationCopyWithImpl<$Res>
    extends _$FirebaseFailuresCopyWithImpl<$Res>
    implements $CancelledOperationCopyWith<$Res> {
  _$CancelledOperationCopyWithImpl(
      CancelledOperation _value, $Res Function(CancelledOperation) _then)
      : super(_value, (v) => _then(v as CancelledOperation));

  @override
  CancelledOperation get _value => super._value as CancelledOperation;
}

/// @nodoc

class _$CancelledOperation extends CancelledOperation {
  const _$CancelledOperation() : super._();

  @override
  String toString() {
    return 'FirebaseFailures.cancelledOperation()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is CancelledOperation);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledOperation,
    required TResult Function() objectNotFound,
    required TResult Function() unknown,
    required TResult Function() noConnection,
  }) {
    return cancelledOperation();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? cancelledOperation,
    TResult Function()? objectNotFound,
    TResult Function()? unknown,
    TResult Function()? noConnection,
  }) {
    return cancelledOperation?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledOperation,
    TResult Function()? objectNotFound,
    TResult Function()? unknown,
    TResult Function()? noConnection,
    required TResult orElse(),
  }) {
    if (cancelledOperation != null) {
      return cancelledOperation();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CancelledOperation value) cancelledOperation,
    required TResult Function(ObjectNotFound value) objectNotFound,
    required TResult Function(Unknown value) unknown,
    required TResult Function(NoConnection value) noConnection,
  }) {
    return cancelledOperation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(CancelledOperation value)? cancelledOperation,
    TResult Function(ObjectNotFound value)? objectNotFound,
    TResult Function(Unknown value)? unknown,
    TResult Function(NoConnection value)? noConnection,
  }) {
    return cancelledOperation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CancelledOperation value)? cancelledOperation,
    TResult Function(ObjectNotFound value)? objectNotFound,
    TResult Function(Unknown value)? unknown,
    TResult Function(NoConnection value)? noConnection,
    required TResult orElse(),
  }) {
    if (cancelledOperation != null) {
      return cancelledOperation(this);
    }
    return orElse();
  }
}

abstract class CancelledOperation extends FirebaseFailures {
  const factory CancelledOperation() = _$CancelledOperation;
  const CancelledOperation._() : super._();
}

/// @nodoc
abstract class $ObjectNotFoundCopyWith<$Res> {
  factory $ObjectNotFoundCopyWith(
          ObjectNotFound value, $Res Function(ObjectNotFound) then) =
      _$ObjectNotFoundCopyWithImpl<$Res>;
}

/// @nodoc
class _$ObjectNotFoundCopyWithImpl<$Res>
    extends _$FirebaseFailuresCopyWithImpl<$Res>
    implements $ObjectNotFoundCopyWith<$Res> {
  _$ObjectNotFoundCopyWithImpl(
      ObjectNotFound _value, $Res Function(ObjectNotFound) _then)
      : super(_value, (v) => _then(v as ObjectNotFound));

  @override
  ObjectNotFound get _value => super._value as ObjectNotFound;
}

/// @nodoc

class _$ObjectNotFound extends ObjectNotFound {
  const _$ObjectNotFound() : super._();

  @override
  String toString() {
    return 'FirebaseFailures.objectNotFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is ObjectNotFound);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledOperation,
    required TResult Function() objectNotFound,
    required TResult Function() unknown,
    required TResult Function() noConnection,
  }) {
    return objectNotFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? cancelledOperation,
    TResult Function()? objectNotFound,
    TResult Function()? unknown,
    TResult Function()? noConnection,
  }) {
    return objectNotFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledOperation,
    TResult Function()? objectNotFound,
    TResult Function()? unknown,
    TResult Function()? noConnection,
    required TResult orElse(),
  }) {
    if (objectNotFound != null) {
      return objectNotFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CancelledOperation value) cancelledOperation,
    required TResult Function(ObjectNotFound value) objectNotFound,
    required TResult Function(Unknown value) unknown,
    required TResult Function(NoConnection value) noConnection,
  }) {
    return objectNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(CancelledOperation value)? cancelledOperation,
    TResult Function(ObjectNotFound value)? objectNotFound,
    TResult Function(Unknown value)? unknown,
    TResult Function(NoConnection value)? noConnection,
  }) {
    return objectNotFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CancelledOperation value)? cancelledOperation,
    TResult Function(ObjectNotFound value)? objectNotFound,
    TResult Function(Unknown value)? unknown,
    TResult Function(NoConnection value)? noConnection,
    required TResult orElse(),
  }) {
    if (objectNotFound != null) {
      return objectNotFound(this);
    }
    return orElse();
  }
}

abstract class ObjectNotFound extends FirebaseFailures {
  const factory ObjectNotFound() = _$ObjectNotFound;
  const ObjectNotFound._() : super._();
}

/// @nodoc
abstract class $UnknownCopyWith<$Res> {
  factory $UnknownCopyWith(Unknown value, $Res Function(Unknown) then) =
      _$UnknownCopyWithImpl<$Res>;
}

/// @nodoc
class _$UnknownCopyWithImpl<$Res> extends _$FirebaseFailuresCopyWithImpl<$Res>
    implements $UnknownCopyWith<$Res> {
  _$UnknownCopyWithImpl(Unknown _value, $Res Function(Unknown) _then)
      : super(_value, (v) => _then(v as Unknown));

  @override
  Unknown get _value => super._value as Unknown;
}

/// @nodoc

class _$Unknown extends Unknown {
  const _$Unknown() : super._();

  @override
  String toString() {
    return 'FirebaseFailures.unknown()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Unknown);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledOperation,
    required TResult Function() objectNotFound,
    required TResult Function() unknown,
    required TResult Function() noConnection,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? cancelledOperation,
    TResult Function()? objectNotFound,
    TResult Function()? unknown,
    TResult Function()? noConnection,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledOperation,
    TResult Function()? objectNotFound,
    TResult Function()? unknown,
    TResult Function()? noConnection,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CancelledOperation value) cancelledOperation,
    required TResult Function(ObjectNotFound value) objectNotFound,
    required TResult Function(Unknown value) unknown,
    required TResult Function(NoConnection value) noConnection,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(CancelledOperation value)? cancelledOperation,
    TResult Function(ObjectNotFound value)? objectNotFound,
    TResult Function(Unknown value)? unknown,
    TResult Function(NoConnection value)? noConnection,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CancelledOperation value)? cancelledOperation,
    TResult Function(ObjectNotFound value)? objectNotFound,
    TResult Function(Unknown value)? unknown,
    TResult Function(NoConnection value)? noConnection,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class Unknown extends FirebaseFailures {
  const factory Unknown() = _$Unknown;
  const Unknown._() : super._();
}

/// @nodoc
abstract class $NoConnectionCopyWith<$Res> {
  factory $NoConnectionCopyWith(
          NoConnection value, $Res Function(NoConnection) then) =
      _$NoConnectionCopyWithImpl<$Res>;
}

/// @nodoc
class _$NoConnectionCopyWithImpl<$Res>
    extends _$FirebaseFailuresCopyWithImpl<$Res>
    implements $NoConnectionCopyWith<$Res> {
  _$NoConnectionCopyWithImpl(
      NoConnection _value, $Res Function(NoConnection) _then)
      : super(_value, (v) => _then(v as NoConnection));

  @override
  NoConnection get _value => super._value as NoConnection;
}

/// @nodoc

class _$NoConnection extends NoConnection {
  const _$NoConnection() : super._();

  @override
  String toString() {
    return 'FirebaseFailures.noConnection()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is NoConnection);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelledOperation,
    required TResult Function() objectNotFound,
    required TResult Function() unknown,
    required TResult Function() noConnection,
  }) {
    return noConnection();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? cancelledOperation,
    TResult Function()? objectNotFound,
    TResult Function()? unknown,
    TResult Function()? noConnection,
  }) {
    return noConnection?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelledOperation,
    TResult Function()? objectNotFound,
    TResult Function()? unknown,
    TResult Function()? noConnection,
    required TResult orElse(),
  }) {
    if (noConnection != null) {
      return noConnection();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CancelledOperation value) cancelledOperation,
    required TResult Function(ObjectNotFound value) objectNotFound,
    required TResult Function(Unknown value) unknown,
    required TResult Function(NoConnection value) noConnection,
  }) {
    return noConnection(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(CancelledOperation value)? cancelledOperation,
    TResult Function(ObjectNotFound value)? objectNotFound,
    TResult Function(Unknown value)? unknown,
    TResult Function(NoConnection value)? noConnection,
  }) {
    return noConnection?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CancelledOperation value)? cancelledOperation,
    TResult Function(ObjectNotFound value)? objectNotFound,
    TResult Function(Unknown value)? unknown,
    TResult Function(NoConnection value)? noConnection,
    required TResult orElse(),
  }) {
    if (noConnection != null) {
      return noConnection(this);
    }
    return orElse();
  }
}

abstract class NoConnection extends FirebaseFailures {
  const factory NoConnection() = _$NoConnection;
  const NoConnection._() : super._();
}
